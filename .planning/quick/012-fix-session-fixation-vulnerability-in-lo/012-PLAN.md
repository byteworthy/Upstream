---
phase: quick-012
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - upstream/views/__init__.py
  - upstream/settings/base.py
autonomous: true

must_haves:
  truths:
    - "Session key changes after logout to prevent fixation"
    - "Logout context still displays correctly on logged_out page"
    - "SESSION_SAVE_EVERY_REQUEST prevents session hijacking during active use"
  artifacts:
    - path: "upstream/views/__init__.py"
      provides: "CustomLogoutView with session.flush()"
      contains: "session.flush()"
    - path: "upstream/settings/base.py"
      provides: "SESSION_SAVE_EVERY_REQUEST configuration"
      contains: "SESSION_SAVE_EVERY_REQUEST = True"
  key_links:
    - from: "CustomLogoutView.dispatch()"
      to: "session.flush()"
      via: "Clears session and regenerates key"
      pattern: "request\\.session\\.flush\\(\\)"
---

<objective>
Fix session fixation vulnerability in logout by implementing proper session key regeneration.

Purpose: Prevents session fixation attacks where an attacker could set a victim's session ID before authentication and hijack the session after logout. This is a HIPAA security requirement for healthcare applications handling PHI.

Output: Secure logout implementation with session.flush() and verified SESSION_SAVE_EVERY_REQUEST configuration.
</objective>

<execution_context>
@/home/codespace/.claude/get-shit-done/workflows/execute-plan.md
@/home/codespace/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@upstream/views/__init__.py
@upstream/settings/base.py
@upstream/urls.py
</context>

<tasks>

<task type="auto">
  <name>Implement session.flush() in CustomLogoutView</name>
  <files>upstream/views/__init__.py</files>
  <action>
Update CustomLogoutView.dispatch() method (lines 841-857) to implement secure logout:

1. BEFORE calling super().dispatch(), call request.session.flush()
   - This clears all session data AND regenerates the session key
   - Prevents session fixation by ensuring the old session ID is invalid

2. Move logout_context storage BEFORE session.flush():
   - Capture user context (was_operator, username, customer_name, role)
   - Store in a temporary variable instead of request.session
   - Pass context via messages or response instead

3. Update template rendering:
   - Override get_context_data() to inject the captured context
   - Store context in instance variable before flush
   - Pass to template via context, not session

Implementation approach:
```python
class CustomLogoutView(DjangoLogoutView):
    template_name = "upstream/logged_out.html"

    def dispatch(self, request, *args, **kwargs):
        # Capture user context BEFORE logout
        self._logout_context = {}
        if request.user.is_authenticated:
            if request.user.is_superuser:
                self._logout_context["was_operator"] = True
                self._logout_context["username"] = request.user.username
            elif hasattr(request.user, "profile") and request.user.profile:
                self._logout_context["was_operator"] = False
                self._logout_context["customer_name"] = request.user.profile.customer.name
                self._logout_context["role"] = request.user.profile.get_role_display()
                self._logout_context["username"] = request.user.username

        # Flush session to prevent fixation (before parent logout)
        request.session.flush()

        return super().dispatch(request, *args, **kwargs)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context.update(getattr(self, '_logout_context', {}))
        return context
```

Why this approach:
- session.flush() clears ALL session data and regenerates session key
- Prevents session fixation by invalidating old session ID
- Context stored in instance variable survives logout
- More secure than storing context in session after authentication ends
  </action>
  <verify>
1. Run tests: `python manage.py test upstream.tests.test_auth --pattern="*logout*" -v 2`
2. Grep for session.flush() usage: `grep -n "session\.flush()" upstream/views/__init__.py`
3. Check that CustomLogoutView no longer writes to request.session after user check
4. Verify get_context_data() method exists and returns _logout_context
  </verify>
  <done>
- CustomLogoutView calls request.session.flush() before super().dispatch()
- User context captured in instance variable, not session
- get_context_data() passes context to template
- No session writes after authentication check
  </done>
</task>

<task type="auto">
  <name>Verify SESSION_SAVE_EVERY_REQUEST configuration</name>
  <files>upstream/settings/base.py</files>
  <action>
Verify SESSION_SAVE_EVERY_REQUEST is enabled in settings (line 385).

Current state check:
1. Confirm SESSION_SAVE_EVERY_REQUEST = True is present
2. This setting ensures session key rotates on every request during active use
3. Complements session.flush() by preventing fixation during active sessions

Add security comment explaining the defense-in-depth strategy:

```python
# Session Security Configuration
SESSION_ENGINE = "django.contrib.sessions.backends.cache"
SESSION_CACHE_ALIAS = "default"  # Use default cache (Redis)
SESSION_COOKIE_AGE = 1800  # 30 minutes idle timeout (healthcare standard)
SESSION_EXPIRE_AT_BROWSER_CLOSE = True  # Close browser = logout
SESSION_SAVE_EVERY_REQUEST = True  # Refresh session key on each request (prevents fixation)
SESSION_COOKIE_HTTPONLY = True  # Prevent JavaScript access to session cookie
SESSION_COOKIE_SAMESITE = "Lax"  # CSRF protection (Lax allows normal navigation)
# SESSION_COOKIE_SECURE set in prod.py (requires HTTPS)
```

If SESSION_SAVE_EVERY_REQUEST is False or missing, set it to True.
  </action>
  <verify>
1. Run: `grep -n "SESSION_SAVE_EVERY_REQUEST" upstream/settings/base.py`
2. Confirm value is True with security comment
3. Run settings validation: `python manage.py check --deploy`
  </verify>
  <done>
- SESSION_SAVE_EVERY_REQUEST = True confirmed in base.py
- Security comment added explaining session fixation prevention
- Django deployment check passes with no session security warnings
  </done>
</task>

<task type="auto">
  <name>Add test for session fixation prevention</name>
  <files>upstream/tests.py</files>
  <action>
Add test case to verify session key changes after logout.

Create TestSessionFixationPrevention test class in upstream/tests.py:

```python
class TestSessionFixationPrevention(TestCase):
    """Test session fixation vulnerability is prevented in logout."""

    def setUp(self):
        self.client = Client()
        self.user = User.objects.create_user(
            username='testuser',
            password='testpass123'  # pragma: allowlist secret
        )

    def test_logout_regenerates_session_key(self):
        """Session key should change after logout to prevent fixation."""
        # Login and capture session key
        self.client.login(username='testuser', password='testpass123')  # pragma: allowlist secret
        session_key_before = self.client.session.session_key

        # Logout
        response = self.client.get('/portal/logout/')

        # Session key should be different after logout
        session_key_after = self.client.session.session_key
        self.assertNotEqual(
            session_key_before,
            session_key_after,
            "Session key must change after logout to prevent fixation"
        )

    def test_logout_context_still_displays(self):
        """Logout page should still show user context despite session.flush()."""
        # Create superuser for testing operator context
        superuser = User.objects.create_superuser(
            username='admin',
            password='admin123',  # pragma: allowlist secret
            email='admin@example.com'
        )

        self.client.login(username='admin', password='admin123')  # pragma: allowlist secret
        response = self.client.get('/portal/logout/')

        # Context should be passed to template
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'admin')  # Username should appear
```

Add these tests to the existing upstream/tests.py file, after other auth tests.
  </action>
  <verify>
1. Run the new tests: `python manage.py test upstream.tests.TestSessionFixationPrevention -v 2`
2. Verify both tests pass
3. Check test coverage: `pytest --cov=upstream.views --cov-report=term-missing -k "session_fixation"`
  </verify>
  <done>
- TestSessionFixationPrevention class added to upstream/tests.py
- test_logout_regenerates_session_key passes (session key changes)
- test_logout_context_still_displays passes (context renders correctly)
- Tests verify security fix without breaking existing functionality
  </done>
</task>

</tasks>

<verification>
1. Run full test suite: `python manage.py test upstream -v 2`
2. Manual logout flow test:
   - Login at http://localhost:8000/portal/login/
   - Check session cookie value in browser dev tools
   - Logout at http://localhost:8000/portal/logout/
   - Verify session cookie value changed
   - Verify logout page shows correct user context
3. Security scan: Run `.agents/skills/checking-session-security/scripts/session_security_scanner.py` if available
4. Check TECHNICAL_DEBT.md: Verify "Session fixation risk in logout" is resolved
</verification>

<success_criteria>
- [ ] CustomLogoutView calls request.session.flush() before parent dispatch
- [ ] Session key regenerates on logout (test verifies this)
- [ ] Logout context still displays correctly on logged_out.html
- [ ] SESSION_SAVE_EVERY_REQUEST = True confirmed in settings
- [ ] All tests pass including new session fixation tests
- [ ] No session security warnings in `python manage.py check --deploy`
- [ ] Session fixation vulnerability closed in TECHNICAL_DEBT.md
</success_criteria>

<output>
After completion, create `.planning/quick/012-fix-session-fixation-vulnerability-in-lo/012-SUMMARY.md`
</output>
