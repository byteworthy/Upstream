---
phase: 02-api-pagination-and-filtering
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - upstream/api/views.py
  - upstream/tests_api.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "payer_summary action returns paginated response with page_size control"
    - "API tests verify pagination works on custom actions"
    - "API tests verify DjangoFilterBackend filters work correctly"
    - "OpenAPI schema shows filter parameters for all filterable endpoints"
  artifacts:
    - path: "upstream/api/views.py"
      provides: "Custom actions with pagination (payer_summary)"
      contains: "self.paginate_queryset"
    - path: "upstream/tests_api.py"
      provides: "Tests for pagination and filtering"
      contains: "test_claim_record_filter"
  key_links:
    - from: "upstream/api/views.py ClaimRecordViewSet.payer_summary"
      to: "self.paginate_queryset"
      via: "pagination method call"
      pattern: "paginate_queryset"
---

<objective>
Add pagination to custom actions and verify filtering with tests

Purpose: Custom ViewSet actions (payer_summary) need manual pagination since DRF's automatic pagination only applies to list(). Tests ensure filters work correctly and OpenAPI documents all parameters.

Output: payer_summary returns paginated responses, comprehensive tests for filtering and pagination, verified OpenAPI documentation.
</objective>

<execution_context>
@/home/codespace/.claude/get-shit-done/workflows/execute-plan.md
@/home/codespace/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-api-pagination-and-filtering/02-RESEARCH.md
@.planning/phases/02-api-pagination-and-filtering/02-01-SUMMARY.md

Key files:
@upstream/api/views.py - ViewSets with custom actions
@upstream/tests_api.py - Existing API tests
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pagination to payer_summary custom action</name>
  <files>
    upstream/api/views.py
  </files>
  <action>
Update the payer_summary action in ClaimRecordViewSet to return paginated results:

1. Modify the payer_summary method to paginate the results list:
   ```python
   @extend_schema(
       summary="Get payer summary statistics",
       responses={200: PayerSummarySerializer(many=True)},
       parameters=[
           {
               "name": "start_date",
               "in": "query",
               "description": "Start date (YYYY-MM-DD). Defaults to 90 days ago.",
               "required": False,
               "schema": {"type": "string", "format": "date"},
           },
           {
               "name": "end_date",
               "in": "query",
               "description": "End date (YYYY-MM-DD). Defaults to today.",
               "required": False,
               "schema": {"type": "string", "format": "date"},
           },
       ],
   )
   @action(detail=False, methods=["get"])
   def payer_summary(self, request):
       """
       Get aggregated statistics by payer.

       Performance: Defaults to last 90 days to prevent expensive
       full-table aggregation. Override with start_date/end_date params.
       """
       # ... existing date parsing and validation code ...

       # Get from cache or compute and store
       results = cache.get_or_set(cache_key, compute_payer_summary, cache_ttl)

       # Apply pagination to results list
       page = self.paginate_queryset(results)
       if page is not None:
           serializer = PayerSummarySerializer(page, many=True)
           return self.get_paginated_response(serializer.data)

       serializer = PayerSummarySerializer(results, many=True)
       return Response(serializer.data)
   ```

Key changes:
- After getting results from cache, call self.paginate_queryset(results)
- Return self.get_paginated_response() if page is not None
- This allows ?page=2&page_size=10 on the payer_summary endpoint

Note: The `active` action on DriftEventViewSet already has pagination (added previously). Verify it follows the same pattern.
  </action>
  <verify>
    Run: curl -X GET "http://localhost:8000/api/v1/claims/payer_summary/?page=1" (with auth)
    Response should include: count, next, previous, results
  </verify>
  <done>
    payer_summary returns paginated response with count, next, previous, results structure
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for filtering and pagination</name>
  <files>
    upstream/tests_api.py
  </files>
  <action>
Add comprehensive tests for the new filtering and pagination functionality:

1. Add filter tests for ClaimRecordViewSet:
   ```python
   class ClaimRecordFilterTests(UpstreamAPITestCase):
       """Tests for ClaimRecord filtering via DjangoFilterBackend."""

       def setUp(self):
           super().setUp()
           # Create test claims with different attributes
           self.claim1 = ClaimRecord.objects.create(
               customer=self.customer,
               upload=self.upload,
               claim_number='CLM001',
               payer='Aetna',
               outcome='PAID',
               decided_date='2024-06-15',
               submitted_date='2024-06-01',
               allowed_amount=100.00,
               cpt_code='99213',
           )
           self.claim2 = ClaimRecord.objects.create(
               customer=self.customer,
               upload=self.upload,
               claim_number='CLM002',
               payer='Blue Cross',
               outcome='DENIED',
               decided_date='2024-07-20',
               submitted_date='2024-07-01',
               allowed_amount=200.00,
               cpt_code='99214',
           )

       def test_filter_by_payer_icontains(self):
           """Test filtering claims by payer name (partial match)."""
           response = self.client.get(f'{API_BASE}/claims/?payer=aet')
           self.assertEqual(response.status_code, 200)
           self.assertEqual(len(response.data['results']), 1)
           self.assertEqual(response.data['results'][0]['payer'], 'Aetna')

       def test_filter_by_outcome(self):
           """Test filtering claims by outcome."""
           response = self.client.get(f'{API_BASE}/claims/?outcome=denied')
           self.assertEqual(response.status_code, 200)
           self.assertEqual(len(response.data['results']), 1)
           self.assertEqual(response.data['results'][0]['outcome'], 'DENIED')

       def test_filter_by_date_range(self):
           """Test filtering claims by date range."""
           response = self.client.get(
               f'{API_BASE}/claims/?start_date=2024-07-01&end_date=2024-07-31'
           )
           self.assertEqual(response.status_code, 200)
           self.assertEqual(len(response.data['results']), 1)
           self.assertEqual(response.data['results'][0]['claim_number'], 'CLM002')

       def test_search_by_claim_number(self):
           """Test searching claims by claim number."""
           response = self.client.get(f'{API_BASE}/claims/?search=CLM001')
           self.assertEqual(response.status_code, 200)
           self.assertEqual(len(response.data['results']), 1)
           self.assertEqual(response.data['results'][0]['claim_number'], 'CLM001')

       def test_search_by_payer(self):
           """Test searching claims by payer name."""
           response = self.client.get(f'{API_BASE}/claims/?search=blue')
           self.assertEqual(response.status_code, 200)
           self.assertEqual(len(response.data['results']), 1)
           self.assertEqual(response.data['results'][0]['payer'], 'Blue Cross')

       def test_combined_filters(self):
           """Test combining multiple filters."""
           response = self.client.get(
               f'{API_BASE}/claims/?payer=aet&outcome=paid'
           )
           self.assertEqual(response.status_code, 200)
           self.assertEqual(len(response.data['results']), 1)
   ```

2. Add filter tests for DriftEventViewSet:
   ```python
   class DriftEventFilterTests(UpstreamAPITestCase):
       """Tests for DriftEvent filtering via DjangoFilterBackend."""

       def setUp(self):
           super().setUp()
           # Create a report run first
           self.report = ReportRun.objects.create(
               customer=self.customer,
               run_type='weekly',
               status='success',
           )
           self.drift1 = DriftEvent.objects.create(
               customer=self.customer,
               report_run=self.report,
               payer='Aetna',
               drift_type='DENIAL_RATE',
               severity=0.8,
               delta_value=0.15,
           )
           self.drift2 = DriftEvent.objects.create(
               customer=self.customer,
               report_run=self.report,
               payer='Blue Cross',
               drift_type='PAYMENT_TIMING',
               severity=0.3,
               delta_value=5.0,
           )

       def test_filter_by_min_severity(self):
           """Test filtering drift events by minimum severity."""
           response = self.client.get(f'{API_BASE}/drift-events/?min_severity=0.5')
           self.assertEqual(response.status_code, 200)
           self.assertEqual(len(response.data['results']), 1)
           self.assertEqual(response.data['results'][0]['severity'], '0.80')

       def test_filter_by_drift_type(self):
           """Test filtering drift events by type."""
           response = self.client.get(f'{API_BASE}/drift-events/?drift_type=denial_rate')
           self.assertEqual(response.status_code, 200)
           self.assertEqual(len(response.data['results']), 1)
           self.assertEqual(response.data['results'][0]['drift_type'], 'DENIAL_RATE')

       def test_filter_by_payer(self):
           """Test filtering drift events by payer."""
           response = self.client.get(f'{API_BASE}/drift-events/?payer=blue')
           self.assertEqual(response.status_code, 200)
           self.assertEqual(len(response.data['results']), 1)
           self.assertEqual(response.data['results'][0]['payer'], 'Blue Cross')

       def test_search_drift_events(self):
           """Test searching drift events."""
           response = self.client.get(f'{API_BASE}/drift-events/?search=aetna')
           self.assertEqual(response.status_code, 200)
           self.assertEqual(len(response.data['results']), 1)
   ```

3. Add pagination test for payer_summary:
   ```python
   class PaginationTests(UpstreamAPITestCase):
       """Tests for API pagination."""

       def test_payer_summary_paginated(self):
           """Test that payer_summary returns paginated response."""
           # Create claims for multiple payers
           for i in range(5):
               ClaimRecord.objects.create(
                   customer=self.customer,
                   upload=self.upload,
                   claim_number=f'CLM{i:03d}',
                   payer=f'Payer{i}',
                   outcome='PAID',
                   decided_date='2024-06-15',
                   submitted_date='2024-06-01',
                   allowed_amount=100.00,
               )

           response = self.client.get(f'{API_BASE}/claims/payer_summary/')
           self.assertEqual(response.status_code, 200)
           # Check paginated response structure
           self.assertIn('count', response.data)
           self.assertIn('results', response.data)
           self.assertIn('next', response.data)
           self.assertIn('previous', response.data)

       def test_list_pagination(self):
           """Test that list endpoints are paginated."""
           response = self.client.get(f'{API_BASE}/claims/')
           self.assertEqual(response.status_code, 200)
           self.assertIn('count', response.data)
           self.assertIn('results', response.data)
   ```

Important: Use the existing test base class (UpstreamAPITestCase) and API_BASE constant. The tests should be added to the existing test file, following the established patterns.
  </action>
  <verify>
    Run: python manage.py test upstream.tests_api.ClaimRecordFilterTests -v 2
    Run: python manage.py test upstream.tests_api.DriftEventFilterTests -v 2
    Run: python manage.py test upstream.tests_api.PaginationTests -v 2
  </verify>
  <done>
    Tests pass for filtering (payer, outcome, date range, severity), search, and pagination
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify OpenAPI documentation shows filters</name>
  <files>
    (verification only - no file changes)
  </files>
  <action>
Verify that drf-spectacular automatically documents the filters in the OpenAPI schema:

1. Generate the OpenAPI schema:
   ```bash
   python manage.py spectacular --file schema.yaml
   ```

2. Check that filter parameters are documented:
   - /api/v1/claims/ should show: payer, outcome, start_date, end_date, search parameters
   - /api/v1/drift-events/ should show: payer, drift_type, min_severity, max_severity, search parameters

3. Verify in browsable API:
   - Visit /api/v1/claims/ in browser
   - Filter controls should be visible
   - Search box should be present

4. Check OpenAPI schema structure (optional):
   ```bash
   grep -A 5 "parameters:" schema.yaml | head -50
   ```

If filters are NOT showing in the schema:
- Ensure 'django_filters' is in INSTALLED_APPS
- Check that filter_backends is set on ViewSets
- Verify drf-spectacular version is 0.27+ (auto-detects filters)

Note: drf-spectacular automatically detects DjangoFilterBackend and generates parameter documentation. No manual @extend_schema annotations needed for basic filters.
  </action>
  <verify>
    Run: python manage.py spectacular --validate
    Check: OpenAPI schema includes filter parameters for /claims/ and /drift-events/
  </verify>
  <done>
    OpenAPI schema shows all filter and search parameters, drf-spectacular validation passes
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Pagination on custom actions:**
   ```bash
   # payer_summary should return paginated response
   curl -H "Authorization: Bearer $TOKEN" \
     "http://localhost:8000/api/v1/claims/payer_summary/"

   # Response should have: count, next, previous, results
   ```

2. **All filter tests pass:**
   ```bash
   python manage.py test upstream.tests_api -k filter -v 2
   python manage.py test upstream.tests_api -k pagination -v 2
   ```

3. **OpenAPI schema validation:**
   ```bash
   python manage.py spectacular --validate
   ```

4. **Full test suite:**
   ```bash
   python manage.py test upstream.tests_api -v 2
   ```

5. **Browsable API verification:**
   - Visit /api/v1/claims/ in browser (with session auth)
   - Filter controls visible
   - Search box present
   - Pagination controls work
</verification>

<success_criteria>
- payer_summary returns paginated response with count, next, previous, results
- ClaimRecordFilterTests pass (payer, outcome, date range, search)
- DriftEventFilterTests pass (severity, drift_type, payer, search)
- PaginationTests pass (payer_summary, list endpoints)
- OpenAPI schema includes filter parameters
- drf-spectacular validation passes
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-pagination-and-filtering/02-02-SUMMARY.md`
</output>
