---
phase: 03-openapi-documentation-and-error-standardization
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - upstream/api/exceptions.py
  - upstream/api/views.py
  - upstream/tests_api.py
autonomous: true

must_haves:
  truths:
    - "All API endpoints return errors in consistent format with code, message, details"
    - "Validation errors include field-level details for client-side error display"
    - "Authentication errors (401) return standardized response structure"
    - "Permission errors (403) return standardized response structure"
    - "Not found errors (404) return standardized response structure"
    - "Throttle errors (429) return standardized response with wait_seconds"
    - "OpenAPI schema documents error response format for all status codes"
  artifacts:
    - path: "upstream/api/exceptions.py"
      provides: "Enhanced exception handler with RFC 7807-compatible format"
      min_lines: 220
    - path: "upstream/api/views.py"
      provides: "Error response schemas referenced in @extend_schema decorators"
      contains: "ErrorResponseSerializer"
    - path: "upstream/tests_api.py"
      provides: "Tests verifying error response format consistency"
      min_lines: 2500
  key_links:
    - from: "upstream/api/views.py"
      to: "upstream/api/exceptions.py"
      via: "REST_FRAMEWORK['EXCEPTION_HANDLER'] setting"
      pattern: "custom_exception_handler"
    - from: "upstream/api/views.py"
      to: "ErrorResponseSerializer"
      via: "@extend_schema responses parameter"
      pattern: "responses=\\{.*ErrorResponseSerializer"
---

<objective>
Standardize error responses across all API endpoints and document error formats in OpenAPI schema.

Purpose: Provide predictable, parseable error responses that API consumers can handle programmatically. Current exception handler provides basic error format but lacks comprehensive OpenAPI documentation and some error types don't include necessary debugging information.

Output: Enhanced exception handler with consistent error structure, OpenAPI schema documenting all error responses, and tests verifying error format compliance.
</objective>

<execution_context>
@/home/codespace/.claude/get-shit-done/workflows/execute-plan.md
@/home/codespace/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/workspaces/codespaces-django/.planning/PROJECT.md
@/workspaces/codespaces-django/.planning/ROADMAP.md
@/workspaces/codespaces-django/.planning/STATE.md
@/workspaces/codespaces-django/.planning/phases/03-openapi-documentation-and-error-standardization/03-CONTEXT.md
@/workspaces/codespaces-django/.planning/phases/03-openapi-documentation-and-error-standardization/03-RESEARCH.md
@/workspaces/codespaces-django/.planning/phases/03-openapi-documentation-and-error-standardization/03-01-PLAN.md

Current state:
- Exception handler at upstream/api/exceptions.py returns {"error": {"code": "", "message": "", "details": null}}
- Format is simple and working but not RFC 7807-aligned
- No OpenAPI schema documentation for error responses
- Tests exist for happy path but minimal error response validation

Plan 03-01 output:
- All ViewSets have @extend_schema decorators with error response placeholders (OpenApiTypes.OBJECT)
- Need to replace placeholders with actual error schema references
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorResponseSerializer for OpenAPI schema</name>
  <files>upstream/api/serializers.py</files>
  <action>
Add error response schema serializers to upstream/api/serializers.py for OpenAPI documentation:

1. Create ErrorResponseSerializer (top-level error response):
```python
class ErrorResponseSerializer(serializers.Serializer):
    """Standardized error response format for all API endpoints"""
    error = serializers.DictField(
        help_text="Error details containing code, message, and optional field-level details"
    )

    class Meta:
        # Add example to show structure
        pass
```

2. Create ErrorDetailSerializer (nested error structure):
```python
class ErrorDetailSerializer(serializers.Serializer):
    """Error detail structure"""
    code = serializers.CharField(
        help_text="Machine-readable error code (e.g., validation_error, not_found)"
    )
    message = serializers.CharField(
        help_text="Human-readable error message"
    )
    details = serializers.JSONField(
        required=False,
        allow_null=True,
        help_text="Field-level validation errors or additional context"
    )
```

3. Add @extend_schema_serializer with OpenApiExample showing common error formats:
   - Validation error with field details
   - Authentication error
   - Permission denied error
   - Not found error
   - Throttled error with wait_seconds

Position: After existing serializers, before view imports.
  </action>
  <verify>
1. Run: python manage.py check
2. Verify: No errors about serializer imports
3. Run: python manage.py spectacular --file /tmp/schema.yaml
4. Check: grep -A 5 "ErrorResponseSerializer" /tmp/schema.yaml shows schema definition
  </verify>
  <done>ErrorResponseSerializer and ErrorDetailSerializer created with examples. OpenAPI schema can reference these for error response documentation.</done>
</task>

<task type="auto">
  <name>Task 2: Update @extend_schema decorators to reference ErrorResponseSerializer</name>
  <files>upstream/api/views.py</files>
  <action>
Replace OpenApiTypes.OBJECT error responses in all @extend_schema decorators with ErrorResponseSerializer references:

**Find and replace pattern:**
- Old: `400: OpenApiTypes.OBJECT`, `401: OpenApiTypes.OBJECT`, etc.
- New: `400: ErrorResponseSerializer`, `401: ErrorResponseSerializer`, etc.

**Add import at top of views.py:**
```python
from .serializers import ErrorResponseSerializer
```

**Apply to all ViewSets from Plan 03-01:**
- CustomerViewSet
- SettingsViewSet
- UploadViewSet
- ClaimRecordViewSet
- ReportRunViewSet
- DriftEventViewSet
- PayerMappingViewSet
- CPTGroupMappingViewSet
- AlertEventViewSet

**Apply to custom actions:**
- Any @action decorators with @extend_schema should also reference ErrorResponseSerializer

**Standard error responses:**
- 400 (validation): ErrorResponseSerializer
- 401 (auth): ErrorResponseSerializer
- 403 (permission): ErrorResponseSerializer
- 404 (not found): ErrorResponseSerializer
- 429 (throttled): ErrorResponseSerializer
- 500 (server error): ErrorResponseSerializer (if documented)

Do NOT change 2xx success responses - only error responses (4xx, 5xx).
  </action>
  <verify>
1. Run: python manage.py spectacular --validate
2. Verify: No errors about missing ErrorResponseSerializer
3. Run: python manage.py spectacular --file /tmp/schema.yaml
4. Check: grep -c "ErrorResponseSerializer" /tmp/schema.yaml shows multiple references
5. Verify: schema.yaml shows consistent error structure for all endpoints
  </verify>
  <done>All @extend_schema error responses reference ErrorResponseSerializer. OpenAPI schema shows consistent, documented error format across all endpoints.</done>
</task>

<task type="auto">
  <name>Task 3: Enhance exception handler with request context and optional RFC 7807 fields</name>
  <files>upstream/api/exceptions.py</files>
  <action>
Enhance custom_exception_handler in upstream/api/exceptions.py to add debugging context:

1. Add request_id to error responses (if available from middleware):
```python
request_id = None
if context and "request" in context:
    request = context["request"]
    request_id = getattr(request, "id", None)  # From RequestIdMiddleware
```

2. For 500 errors, include request_id in details for support tracking:
```python
details = {"request_id": request_id} if request_id else None
```

3. For throttled errors, ensure wait_seconds is in details (already exists, verify format):
```python
details = {
    "wait_seconds": exc.wait if hasattr(exc, "wait") else None,
    "request_id": request_id
}
```

4. Add optional "type" field for RFC 7807 compatibility (not required, but helpful):
   - Add type field to error response: error_code mapped to URI
   - Keep existing code/message/details structure (backward compatible)
   - Example: "type": "/errors/validation-error" for validation_error code

5. Preserve all existing error codes and messages - this is enhancement only.

6. Update docstring to document enhanced error format and RFC 7807 alignment.

**Important:** Keep backward compatibility. Existing error format must not break.
  </action>
  <verify>
1. Run: python manage.py test upstream.tests_api
2. Verify: Existing error tests still pass (format compatible)
3. Test validation error: Create invalid POST request
4. Check response includes: error.code, error.message, error.details with field errors
5. Test throttle error: Exceed rate limit, verify wait_seconds in response
  </verify>
  <done>Exception handler enhanced with request_id tracking and optional RFC 7807 type field. Error responses include debugging context while maintaining backward compatibility.</done>
</task>

<task type="auto">
  <name>Task 4: Add comprehensive error response tests</name>
  <files>upstream/tests_api.py</files>
  <action>
Add ErrorResponseTests class to upstream/tests_api.py verifying error format consistency:

**Test coverage:**

1. test_validation_error_format:
   - POST invalid data to ClaimRecord endpoint
   - Assert response.status_code == 400
   - Assert "error" in response.data
   - Assert response.data["error"]["code"] == "validation_error"
   - Assert response.data["error"]["message"] is string
   - Assert response.data["error"]["details"] contains field names

2. test_authentication_error_format:
   - GET endpoint without auth token
   - Assert status_code == 401
   - Assert error.code == "authentication_failed"
   - Verify consistent structure

3. test_permission_error_format:
   - Authenticate as customer_viewer
   - POST/DELETE to endpoint (write operation)
   - Assert status_code == 403
   - Assert error.code == "permission_denied"

4. test_not_found_error_format:
   - GET /api/claims/999999/ (non-existent)
   - Assert status_code == 404
   - Assert error.code == "not_found"
   - Assert error.message is helpful

5. test_throttle_error_format:
   - Make requests exceeding rate limit
   - Assert status_code == 429
   - Assert error.code == "throttled"
   - Assert error.details contains "wait_seconds"

6. test_method_not_allowed_format:
   - PATCH to read-only endpoint
   - Assert status_code == 405
   - Assert error.code == "method_not_allowed"

**Test class structure:**
```python
class ErrorResponseTests(APITestBase):
    """Test error response format consistency"""

    def test_validation_error_format(self):
        # Test validation errors return consistent format
        pass

    # ... other tests
```

Inherit from APITestBase to use existing fixtures and setup.
  </action>
  <verify>
1. Run: python manage.py test upstream.tests_api::ErrorResponseTests
2. Verify: All 6 error format tests pass
3. Check: Each test validates error.code, error.message, error.details structure
4. Run full suite: python manage.py test upstream.tests_api
5. Verify: No regressions in existing tests
  </verify>
  <done>ErrorResponseTests class with 6 tests verifying consistent error format across all error types. Tests cover validation, authentication, permission, not found, throttle, and method not allowed errors.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Error format consistency:
   - Run: python manage.py test upstream.tests_api::ErrorResponseTests
   - Verify: All error format tests pass
   - Check: Every error type has code, message, details structure

2. OpenAPI schema documentation:
   - Run: python manage.py spectacular --file /tmp/schema.yaml
   - Check: grep -A 10 "ErrorResponseSerializer" /tmp/schema.yaml
   - Verify: Error schema includes code, message, details fields
   - Count: grep -c "ErrorResponseSerializer" /tmp/schema.yaml shows usage across endpoints

3. Backward compatibility:
   - Run: python manage.py test upstream.tests_api
   - Verify: All existing tests pass (no breaking changes)
   - Check: Error response structure unchanged for existing consumers

4. Live testing:
   - Start server: python manage.py runserver
   - Test validation error: POST invalid data, verify format
   - Test auth error: Request without token, verify format
   - Test not found: GET /api/claims/999999/, verify format
   - Check: All errors return consistent {"error": {...}} structure

5. Swagger UI error examples:
   - Visit: http://localhost:8000/api/schema/swagger-ui/
   - Check: Error response schemas visible in documentation
   - Verify: Examples show realistic error formats
</verification>

<success_criteria>
1. ErrorResponseSerializer created and referenced in all @extend_schema decorators
2. Exception handler enhanced with request_id and optional RFC 7807 fields
3. ErrorResponseTests with 6 tests verifying error format consistency all pass
4. OpenAPI schema documents error response structure for all endpoints
5. Backward compatibility maintained - existing error consumers not broken
6. All API errors return {"error": {"code": "", "message": "", "details": null}} format
</success_criteria>

<output>
After completion, create `.planning/phases/03-openapi-documentation-and-error-standardization/03-02-SUMMARY.md` using the standard summary template.

Include:
- Error response format structure
- Number of error format tests added
- OpenAPI schema coverage of error responses
- RFC 7807 alignment details
- Any deviations or enhancements beyond plan
</output>
