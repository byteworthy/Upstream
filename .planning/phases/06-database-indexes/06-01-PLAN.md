---
phase: 06-database-indexes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - upstream/models.py
  - upstream/alerts/models.py
  - upstream/migrations/00XX_add_missing_indexes_phase6.py
autonomous: true

must_haves:
  truths:
    - "Permission queries filtering by (customer, role) use composite index instead of full table scan"
    - "Alert rule evaluation ordered by routing_priority uses partial index for enabled rules only"
    - "Index creation completes without downtime using CREATE INDEX CONCURRENTLY"
  artifacts:
    - path: "upstream/models.py"
      provides: "UserProfile model with composite (customer, role) index"
      min_lines: 900
      contains: "userprofile_customer_role_idx"
    - path: "upstream/alerts/models.py"
      provides: "AlertRule model with partial index on routing_priority"
      min_lines: 150
      contains: "alertrule_eval_priority_idx"
    - path: "upstream/migrations/00XX_add_missing_indexes_phase6.py"
      provides: "Migration with AddIndexConcurrently operations"
      exports: ["Migration"]
  key_links:
    - from: "upstream/models.py"
      to: "UserProfile permission queries"
      via: "composite index on (customer, role)"
      pattern: "models\\.Index.*customer.*role"
    - from: "upstream/alerts/models.py"
      to: "AlertRule evaluation ordering"
      via: "partial index WHERE enabled=True"
      pattern: "condition=models\\.Q\\(enabled=True\\)"
---

<objective>
Add two missing database indexes identified in Phase 6 research: UserProfile composite index for permission queries and AlertRule partial index for rule evaluation ordering.

Purpose: Optimize high-frequency permission checks and alert rule evaluation queries that currently lack targeted indexes
Output: Zero-downtime migration adding 2 new indexes using CREATE INDEX CONCURRENTLY
</objective>

<execution_context>
@/workspaces/codespaces-django/.planning/get-shit-done/workflows/execute-plan.md
@/workspaces/codespaces-django/.planning/get-shit-done/templates/summary.md
</execution_context>

<context>
@/workspaces/codespaces-django/.planning/PROJECT.md
@/workspaces/codespaces-django/.planning/ROADMAP.md
@/workspaces/codespaces-django/.planning/STATE.md
@/workspaces/codespaces-django/.planning/phases/06-database-indexes/06-RESEARCH.md
@/workspaces/codespaces-django/upstream/models.py
@/workspaces/codespaces-django/upstream/alerts/models.py
@/workspaces/codespaces-django/upstream/api/permissions.py
@/workspaces/codespaces-django/upstream/alerts/services.py
</context>

<tasks>

<task type="auto">
  <name>Add composite index to UserProfile for permission queries</name>
  <files>
    upstream/models.py
  </files>
  <action>
In upstream/models.py, locate the UserProfile model (around line 868-899).

**Current state:**
- user field has db_index=True (line 882)
- customer field has db_index=True (line 885)
- No Meta class or indexes section

**Add Meta class with composite index:**

After the `is_admin` property (line 898), add:

```python
    class Meta:
        indexes = [
            models.Index(
                fields=["customer", "role"],
                name="userprofile_customer_role_idx",
            ),
        ]
```

**Why this index:**
Query pattern from permissions.py line 131-134:
```python
UserProfile.objects.filter(
    customer=profile.customer,
    role='owner'
).count()
```

This permission check runs on every role-change operation. The composite (customer, role) index allows PostgreSQL to efficiently filter by both columns without scanning all user profiles for the customer.

**Column order reasoning:**
- customer first (high cardinality, ~100-1000 unique customers)
- role second (low cardinality, 4 choices: owner/admin/analyst/viewer)

This matches the query pattern where customer is always present in WHERE clause, and role follows.
  </action>
  <verify>
```bash
cd /workspaces/codespaces-django
grep -A8 "class Meta:" upstream/models.py | grep -A5 "userprofile_customer_role_idx"
```
Expected: Shows Index definition with fields=["customer", "role"]
  </verify>
  <done>
- UserProfile model has Meta class with indexes list
- Index userprofile_customer_role_idx defined on (customer, role)
- Model change ready for makemigrations
  </done>
</task>

<task type="auto">
  <name>Add partial index to AlertRule for evaluation ordering</name>
  <files>
    upstream/alerts/models.py
  </files>
  <action>
In upstream/alerts/models.py, locate the AlertRule Meta class (around line 71-79).

**Current state:**
```python
class Meta:
    verbose_name = "Alert Rule"
    verbose_name_plural = "Alert Rules"
    unique_together = ("customer", "name")
    indexes = [
        models.Index(
            fields=["customer", "enabled"], name="idx_alertrule_customer_enabled"
        ),
    ]
```

**Add partial index to existing indexes list:**

After the existing (customer, enabled) index, add:

```python
        models.Index(
            fields=["customer", "-routing_priority"],
            name="alertrule_eval_priority_idx",
            condition=models.Q(enabled=True),
        ),
```

**Final indexes list should be:**
```python
    indexes = [
        models.Index(
            fields=["customer", "enabled"], name="idx_alertrule_customer_enabled"
        ),
        models.Index(
            fields=["customer", "-routing_priority"],
            name="alertrule_eval_priority_idx",
            condition=models.Q(enabled=True),
        ),
    ]
```

**Why this index:**
Query pattern from alerts/services.py line 48:
```python
AlertRule.objects.filter(customer=drift_event.customer, enabled=True)
```

And from tests_routing.py:
```python
rules = AlertRule.objects.filter(customer=self.customer).order_by('-routing_priority')
```

**Why partial index:**
The enabled=True filter appears in ~99% of queries (disabled rules are rarely queried). The partial index:
- Only indexes enabled=True rows (smaller, faster to maintain)
- Supports descending order on routing_priority for rule evaluation
- Reduces write overhead since disabled rule changes don't update this index

**Why descending (-routing_priority):**
Rules with higher routing_priority values evaluate first. The ORDER BY -routing_priority pattern is optimized by indexing in descending order.
  </action>
  <verify>
```bash
cd /workspaces/codespaces-django
grep -A15 "class Meta:" upstream/alerts/models.py | grep -A3 "alertrule_eval_priority_idx"
```
Expected: Shows partial index with condition=models.Q(enabled=True) and fields containing "-routing_priority"
  </verify>
  <done>
- AlertRule Meta class has 2 indexes (existing + new partial index)
- New index alertrule_eval_priority_idx defined with descending routing_priority
- Partial condition models.Q(enabled=True) present
- Model change ready for makemigrations
  </done>
</task>

<task type="auto">
  <name>Create migration with CONCURRENTLY for zero-downtime deployment</name>
  <files>
    upstream/migrations/00XX_add_missing_indexes_phase6.py
  </files>
  <action>
**Step 1: Generate migration**

```bash
cd /workspaces/codespaces-django
python manage.py makemigrations upstream -n add_missing_indexes_phase6
```

This creates a migration file in upstream/migrations/ with auto-incremented number (likely 0025_add_missing_indexes_phase6.py).

**Step 2: Review generated migration**

Expected structure:
```python
from django.db import migrations, models

class Migration(migrations.Migration):
    dependencies = [
        ("upstream", "0024_update_authorization_multi_vertical"),
    ]

    operations = [
        migrations.AddIndex(
            model_name="userprofile",
            index=models.Index(fields=["customer", "role"], name="userprofile_customer_role_idx"),
        ),
        migrations.AddIndex(
            model_name="alertrule",
            index=models.Index(
                condition=models.Q(enabled=True),
                fields=["customer", "-routing_priority"],
                name="alertrule_eval_priority_idx",
            ),
        ),
    ]
```

**Step 3: Modify for CONCURRENTLY (zero-downtime)**

Edit the generated migration to use AddIndexConcurrently and atomic=False:

```python
from django.db import migrations, models
from django.contrib.postgres.operations import AddIndexConcurrently

class Migration(migrations.Migration):
    atomic = False  # Required for CONCURRENTLY

    dependencies = [
        ("upstream", "0024_update_authorization_multi_vertical"),
    ]

    operations = [
        AddIndexConcurrently(
            model_name="userprofile",
            index=models.Index(fields=["customer", "role"], name="userprofile_customer_role_idx"),
        ),
        AddIndexConcurrently(
            model_name="alertrule",
            index=models.Index(
                condition=models.Q(enabled=True),
                fields=["customer", "-routing_priority"],
                name="alertrule_eval_priority_idx",
            ),
        ),
    ]
```

**Why CONCURRENTLY:**
- CREATE INDEX normally acquires SHARE lock on table (blocks writes)
- CREATE INDEX CONCURRENTLY builds index without blocking writes
- Takes 2-3x longer but maintains zero-downtime for production
- Requires atomic=False (no transaction wrapper)

**Step 4: Apply migration**

```bash
python manage.py migrate upstream
```

Expected output:
```
Running migrations:
  Applying upstream.0025_add_missing_indexes_phase6... OK
```

**Step 5: Verify indexes in database**

```bash
python manage.py dbshell <<EOF
-- Check UserProfile index
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'upstream_userprofile'
  AND indexname = 'userprofile_customer_role_idx';

-- Check AlertRule partial index
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'upstream_alertrule'
  AND indexname = 'alertrule_eval_priority_idx';

\q
EOF
```

Expected: Both indexes exist with correct definitions. AlertRule index should show WHERE (enabled = true) condition.
  </action>
  <verify>
```bash
cd /workspaces/codespaces-django
# Verify migration file exists
ls -l upstream/migrations/*add_missing_indexes_phase6.py

# Verify migration applied
python manage.py showmigrations upstream | grep add_missing_indexes_phase6

# Verify SQL includes CONCURRENTLY
python manage.py sqlmigrate upstream $(ls upstream/migrations/*add_missing_indexes_phase6.py | grep -o '[0-9]\{4\}') | grep -i "concurrently"

# Count indexes created (should be 2)
python manage.py dbshell <<EOF
SELECT COUNT(*) FROM pg_indexes
WHERE tablename IN ('upstream_userprofile', 'upstream_alertrule')
  AND indexname IN ('userprofile_customer_role_idx', 'alertrule_eval_priority_idx');
\q
EOF
```
Expected:
- Migration file exists with atomic = False
- Migration marked as [X] applied
- SQL shows CREATE INDEX CONCURRENTLY
- Count returns 2 (both indexes exist)
  </verify>
  <done>
- Migration file created with AddIndexConcurrently operations
- atomic = False set for CONCURRENTLY support
- Migration applied successfully without errors
- Database contains 2 new indexes (verified via pg_indexes)
- Indexes use CONCURRENTLY for zero-downtime
  </done>
</task>

<task type="auto">
  <name>Validate query performance improvement with EXPLAIN ANALYZE</name>
  <files>
    None (database verification only)
  </files>
  <action>
Run EXPLAIN ANALYZE on the queries these indexes optimize to verify improvement.

**Query 1: Permission check (UserProfile)**

```bash
python manage.py dbshell <<EOF
EXPLAIN (ANALYZE, BUFFERS)
SELECT COUNT(*)
FROM upstream_userprofile
WHERE customer_id = 1 AND role = 'owner';
\q
EOF
```

Expected output (AFTER index):
```
Index Scan using userprofile_customer_role_idx on upstream_userprofile
  (cost=0.28..8.30 rows=1 width=8) (actual time=0.015..0.016 rows=1 loops=1)
  Index Cond: ((customer_id = 1) AND ((role)::text = 'owner'::text))
  Buffers: shared hit=3
Planning Time: 0.145 ms
Execution Time: 0.042 ms
```

Key indicators:
- "Index Scan using userprofile_customer_role_idx" (not Seq Scan)
- Low actual time (<1ms)
- Minimal buffers (3-5 pages)

**Query 2: Alert rule evaluation (AlertRule)**

```bash
python manage.py dbshell <<EOF
EXPLAIN (ANALYZE, BUFFERS)
SELECT *
FROM upstream_alertrule
WHERE customer_id = 1 AND enabled = true
ORDER BY routing_priority DESC
LIMIT 10;
\q
EOF
```

Expected output (AFTER index):
```
Index Scan using alertrule_eval_priority_idx on upstream_alertrule
  (cost=0.14..12.16 rows=1 width=XXX) (actual time=0.023..0.025 rows=2 loops=1)
  Index Cond: (customer_id = 1)
  Filter: enabled
  Buffers: shared hit=4
Planning Time: 0.182 ms
Execution Time: 0.058 ms
```

Key indicators:
- "Index Scan using alertrule_eval_priority_idx" (not Seq Scan)
- Partial index WHERE condition satisfied
- DESC ordering supported directly by index
- Low execution time (<1ms)

**If queries still use Seq Scan:**

Possible reasons:
1. Table too small (<1000 rows): PostgreSQL prefers seq scan for tiny tables
2. Statistics not updated: Run ANALYZE upstream_userprofile; ANALYZE upstream_alertrule;
3. Index not fully built: Check pg_stat_progress_create_index for completion

Solutions:
```bash
python manage.py dbshell <<EOF
ANALYZE upstream_userprofile;
ANALYZE upstream_alertrule;
\q
EOF
```

Then re-run EXPLAIN ANALYZE.

**Document results:**

Save query plan outputs to verify improvement for SUMMARY.md.
  </action>
  <verify>
```bash
cd /workspaces/codespaces-django
# Run both EXPLAIN queries and check for "Index Scan" in output
python manage.py dbshell <<EOF
EXPLAIN SELECT COUNT(*) FROM upstream_userprofile WHERE customer_id = 1 AND role = 'owner';
EXPLAIN SELECT * FROM upstream_alertrule WHERE customer_id = 1 AND enabled = true ORDER BY routing_priority DESC LIMIT 10;
\q
EOF
```
Expected: Both queries show "Index Scan using <index_name>" not "Seq Scan"
  </verify>
  <done>
- EXPLAIN ANALYZE confirms UserProfile query uses userprofile_customer_role_idx
- EXPLAIN ANALYZE confirms AlertRule query uses alertrule_eval_priority_idx
- Query execution times <1ms for typical workloads
- Indexes provide measurable performance improvement over seq scan
  </done>
</task>

<task type="auto">
  <name>Run test suite to verify indexes don't break functionality</name>
  <files>
    None (test execution only)
  </files>
  <action>
Run full test suite with --keepdb to verify:
1. No queries broken by new indexes
2. Permission checks still work correctly
3. Alert rule evaluation still works correctly

```bash
cd /workspaces/codespaces-django
python manage.py test upstream.tests --keepdb -v 2
```

**Focus areas:**

1. **Permission tests** (upstream/tests.py or upstream/api/tests/):
   - RBAC tests validating owner/admin/viewer roles
   - Cross-customer isolation tests
   - Role change validation tests

2. **Alert routing tests** (upstream/alerts/tests_routing.py):
   - Rule evaluation order by routing_priority
   - Enabled/disabled rule filtering
   - Multi-customer rule isolation

**Expected results:**
- All tests pass (no regressions)
- Tests exercise indexed queries
- No performance degradation

**If tests fail:**

Common issues:
1. **Index condition doesn't match query:** Partial index WHERE enabled=True but query filters enabled=False
2. **Column order mismatch:** Index on (customer, role) but query filters (role, customer)
3. **Migration dependency issue:** Missing dependency on prior migration

Solution:
- Review failing test query patterns
- Verify index definition matches query filters
- Check migration dependencies are correct

**Test coverage verification:**

Ensure tests cover the indexed queries:
```bash
grep -r "role.*owner" upstream/tests*.py upstream/api/tests/ upstream/alerts/tests*.py
grep -r "routing_priority" upstream/alerts/tests*.py
```

If coverage gaps exist, note in SUMMARY but don't block (indexes are performance optimization, not functionality change).
  </action>
  <verify>
```bash
cd /workspaces/codespaces-django
python manage.py test upstream.tests --keepdb --failfast 2>&1 | tee test_output.txt
grep -E "(OK|FAILED|ERROR)" test_output.txt
```
Expected: Shows "OK" with test count, no FAILED or ERROR
  </verify>
  <done>
- Full test suite runs without errors
- Permission checks pass (UserProfile index tested)
- Alert routing tests pass (AlertRule index tested)
- No performance regressions observed
- Test output confirms index functionality
  </done>
</task>

</tasks>

<verification>
**Overall phase verification:**

1. **Index existence:**
```bash
python manage.py dbshell <<EOF
SELECT tablename, indexname, indexdef
FROM pg_indexes
WHERE indexname IN ('userprofile_customer_role_idx', 'alertrule_eval_priority_idx')
ORDER BY tablename;
\q
EOF
```
Expected: 2 rows showing both indexes with correct definitions

2. **Index usage in queries:**
```bash
# After running application for a few minutes, check index scan counts
python manage.py dbshell <<EOF
SELECT schemaname, tablename, indexname, idx_scan, idx_tup_read
FROM pg_stat_user_indexes
WHERE indexname IN ('userprofile_customer_role_idx', 'alertrule_eval_priority_idx');
\q
EOF
```
Expected: idx_scan > 0 (indexes being used)

3. **Migration rollback safety:**
```bash
# Test rollback capability
python manage.py migrate upstream 0024_update_authorization_multi_vertical
python manage.py migrate upstream  # Re-apply
```
Expected: Rollback and re-apply work without errors

4. **No duplicate indexes:**
```bash
python manage.py dbshell <<EOF
SELECT tablename, COUNT(*) as index_count
FROM pg_indexes
WHERE tablename IN ('upstream_userprofile', 'upstream_alertrule')
GROUP BY tablename;
\q
EOF
```
Expected: Reasonable index counts (UserProfile: 4-5 indexes, AlertRule: 2-3 indexes)
</verification>

<success_criteria>
- [ ] UserProfile model has Meta.indexes with composite (customer, role) index
- [ ] AlertRule model has partial index on (customer, -routing_priority) WHERE enabled=True
- [ ] Migration file exists with AddIndexConcurrently and atomic=False
- [ ] Migration applied successfully without errors
- [ ] Database shows 2 new indexes exist (pg_indexes query)
- [ ] EXPLAIN ANALYZE confirms indexes used by target queries
- [ ] Test suite passes with no regressions
- [ ] Query performance improved (Index Scan vs Seq Scan)
</success_criteria>

<output>
After completion, create `.planning/phases/06-database-indexes/06-01-SUMMARY.md`
</output>
